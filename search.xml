<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>通知所有员工所需的时间 - LeetCode</title>
    <url>/2020/03/14/leetcode-time-needed-to-inform-all-employees/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>通知所有员工所需的时间</p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>公司里有 n 名员工，每个员工的 ID 都是独一无二的，编号从 0 到 n - 1。公司的总负责人通过 headID 进行标识。</p>
<p>在 manager 数组中，每个员工都有一个直属负责人，其中 manager[i] 是第 i 名员工的直属负责人。对于总负责人，manager[headID] = -1。题目保证从属关系可以用树结构显示。</p>
<a id="more"></a>

<p>公司总负责人想要向公司所有员工通告一条紧急消息。他将会首先通知他的直属下属们，然后由这些下属通知他们的下属，直到所有的员工都得知这条紧急消息。</p>
<p>第 i 名员工需要 informTime[i] 分钟来通知它的所有直属下属（也就是说在 informTime[i] 分钟后，他的所有直属下属都可以开始传播这一消息）。</p>
<p>返回通知所有员工这一紧急消息所需要的 分钟数 。</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol>
<li>类似于求树的最长路径</li>
<li>主要思路是递归累加每一个层中管理的最大需要分钟数</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">headID</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">manager</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">informTime</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numOfMinutes = <span class="function"><span class="keyword">function</span>(<span class="params">n, headID, manager, informTime</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> allTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> employeesMap = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; manager.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> === manager[i]) &#123;</span><br><span class="line">            allTime += informTime[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!employeesMap[manager[i]]) &#123;</span><br><span class="line">            employeesMap[manager[i]] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        employeesMap[manager[i]].push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getNum</span>(<span class="params">headID</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> maxTime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> employees = employeesMap[headID];</span><br><span class="line">        <span class="keyword">if</span> (employees) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; employees.length; i++) &#123;</span><br><span class="line">                <span class="keyword">let</span> currTime = getNum(employees[i]);</span><br><span class="line">                maxTime = <span class="built_in">Math</span>.max(</span><br><span class="line">                    maxTime,</span><br><span class="line">                    informTime[employees[i]] + currTime</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allTime + getNum(headID);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<ul>
<li>执行用时: 340 ms, 在所有 JavaScript 提交中击败了 76.39% 的用户</li>
<li>内存消耗: 108.7 MB, 在所有 JavaScript 提交中击败了 100.00% 的用户</li>
</ul>
<h1 id="难度"><a href="#难度" class="headerlink" title="难度"></a>难度</h1><p>中等</p>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/time-needed-to-inform-all-employees/" target="_blank" rel="noopener">通知所有员工所需的时间</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>灯泡开关 III - LeetCode</title>
    <url>/2020/03/14/leetcode-bulb-switcher-iii/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>灯泡开关 III</p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>房间中有 n 枚灯泡，编号从 1 到 n，自左向右排成一排。最初，所有的灯都是关着的。</p>
<p>在 k  时刻（ k 的取值范围是 0 到 n - 1），我们打开 light[k] 这个灯。</p>
<p>灯的颜色要想 变成蓝色 就必须同时满足下面两个条件：</p>
<ul>
<li>灯处于打开状态。</li>
<li>排在它之前（左侧）的所有灯也都处于打开状态。<br>请返回能够让 所有开着的 灯都 变成蓝色 的时刻 数目 。</li>
</ul>
<a id="more"></a>

<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol>
<li>当前灯的开关状态等于之前的灯是否是否全开</li>
<li>判断当前灯的编号累加是否等于开关次数累加</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">light</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numTimesAllBlue = <span class="function"><span class="keyword">function</span>(<span class="params">light</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!light || light.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> blueNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> currNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> allBlueCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; light.length; i++) &#123;</span><br><span class="line">        blueNum += i + <span class="number">1</span>;</span><br><span class="line">        currNum += light[i];</span><br><span class="line">        <span class="keyword">if</span> (blueNum === currNum) &#123;</span><br><span class="line">            allBlueCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> allBlueCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<ul>
<li>执行用时: 76 ms, 在所有 JavaScript 提交中击败了 90.91% 的用户</li>
<li>内存消耗: 40.9 MB, 在所有 JavaScript 提交中击败了 100.00% 的用户</li>
</ul>
<h1 id="难度"><a href="#难度" class="headerlink" title="难度"></a>难度</h1><p>中等</p>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/bulb-switcher-iii/" target="_blank" rel="noopener">灯泡开关 III</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>生成每种字符都是奇数个的字符串 - LeetCode</title>
    <url>/2020/03/14/leetcode-generate-a-string-with-characters-that-have-odd-counts/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>生成每种字符都是奇数个的字符串</p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>给你一个整数 n，请你返回一个含 n 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次。</p>
<p>返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。</p>
<a id="more"></a>

<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol>
<li>没限制返回什么字符，所以只需要生成 1-3 种字符即可</li>
<li>这里只需要判断 n 的奇偶</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generateTheString = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>(n) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>(n) === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'a'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>(n) === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'ab'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> aCount = n % <span class="number">2</span> ? n - <span class="number">2</span> : n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="keyword">new</span> <span class="built_in">Array</span>(aCount).fill(<span class="string">'a'</span>).join(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> ? ans + <span class="string">'bc'</span> : ans + <span class="string">'b'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<ul>
<li>执行用时: 72 ms, 在所有 JavaScript 提交中击败了 50.41% 的用户</li>
<li>内存消耗: 34.5 MB, 在所有 JavaScript 提交中击败了 100.00% 的用户</li>
</ul>
<h1 id="难度"><a href="#难度" class="headerlink" title="难度"></a>难度</h1><p>简单</p>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/generate-a-string-with-characters-that-have-odd-counts/" target="_blank" rel="noopener">生成每种字符都是奇数个的字符串</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>将数组分成和相等的三个部分 - LeetCode</title>
    <url>/2020/03/11/leetcode-partition-array-into-three-parts-with-equal-sum/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>将数组分成和相等的三个部分</p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>给你一个整数数组 <code>A</code>，只有可以将其划分为三个和相等的非空部分时才返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>形式上，如果可以找出索引 <code>i+1 &lt; j</code> 且满足 <code>(A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1])</code> 就可以将数组三等分。</p>
<a id="more"></a>

<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol>
<li>计算数组全部元素相加和的 3 分之一</li>
<li>利用双指针从前后同时开始遍历计算和等于总数 3 分之一的区间</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">A</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canThreePartsEqualSum = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!A || A.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> sumArr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">        sumArr += A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> threePartsSum = sumArr / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> j = A.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> sumLeft = A[i];</span><br><span class="line">    <span class="keyword">let</span> sumRight = A[j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i + <span class="number">1</span> &lt; j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sumLeft === threePartsSum &amp;&amp; sumRight === threePartsSum) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sumLeft != threePartsSum) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            sumLeft += A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sumRight != threePartsSum) &#123;</span><br><span class="line">            j--;</span><br><span class="line">            sumRight += A[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span> &lt; j &amp;&amp; sumLeft === threePartsSum &amp;&amp; sumRight === threePartsSum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<ul>
<li>时间复杂度：<code>O(N)</code>，其中 <code>N</code> 是数组 <code>A</code> 的长度。我们最多只需要遍历一遍数组就可以得到答案。</li>
<li>空间复杂度：<code>O(1)</code>。我们只需要使用额外的索引变量 <code>i</code>，<code>j</code> 以及一些存储数组信息的变量。</li>
</ul>
<p>执行结果：</p>
<ul>
<li>执行用时: 60 ms, 在所有 JavaScript 提交中击败了 100.00% 的用户</li>
<li>内存消耗: 39.7 MB, 在所有 JavaScript 提交中击败了 74.07% 的用户</li>
</ul>
<h1 id="难度"><a href="#难度" class="headerlink" title="难度"></a>难度</h1><p>简单</p>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/" target="_blank" rel="noopener">将数组分成和相等的三个部分</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的直径 - LeetCode</title>
    <url>/2020/03/10/leetcode-diameter-of-binary-tree/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>二叉树的直径</p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</p>
<a id="more"></a>

<p>示例 :<br>给定二叉树</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \     </span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>
<p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol>
<li>深度优先搜索</li>
<li>任意一条路径均可以被看作由某个节点为起点，从其左子树和右子树向下遍历的路径拼接得到</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> diameterOfBinaryTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> depth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">let</span> right = depth(root.right);</span><br><span class="line">        ans = <span class="built_in">Math</span>.max(left + right + <span class="number">1</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    depth(root);</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<ul>
<li>时间复杂度：<code>O(N)</code>，其中 <code>N</code> 为二叉树的节点数，即遍历一棵二叉树的时间复杂度，每个结点只被访问一次。</li>
<li>空间复杂度：<code>O(Height)</code>，其中 <code>Height</code> 为二叉树的高度。由于递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，而递归的深度显然为二叉树的高度，并且每次递归调用的函数里又只用了常数个变量，所以所需空间复杂度为 <code>O(Height)</code>。</li>
</ul>
<p>执行结果：</p>
<ul>
<li>执行用时: 80 ms, 在所有 JavaScript 提交中击败了 55.94% 的用户</li>
<li>内存消耗: 37.9 MB, 在所有 JavaScript 提交中击败了 15.05% 的用户</li>
</ul>
<h1 id="难度"><a href="#难度" class="headerlink" title="难度"></a>难度</h1><p>简单</p>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">二叉树的直径</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>深度优先搜索(DFS)</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 加号运算</title>
    <url>/2020/03/09/javascript-plus-operation/</url>
    <content><![CDATA[<h1 id="加法运算符"><a href="#加法运算符" class="headerlink" title="加法运算符"></a>加法运算符</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>加法运算符是用来连接字符串或数字相加的</p>
<h2 id="运算过程定义"><a href="#运算过程定义" class="headerlink" title="运算过程定义"></a>运算过程定义</h2><blockquote>
<p>AdditiveExpression : AdditiveExpression + MultiplicativeExpression</p>
</blockquote>
<ol>
<li>把AdditiveExpression的result赋值给lref</li>
<li>把GetValue(lref)的结果赋值给lval</li>
<li>把MultiplicativeExpression的result赋值给rref</li>
<li>把GetValue(rref)的结果赋值给rval</li>
<li>把ToPrimitive(lval)的结果赋值给lprim</li>
<li>把ToPrimitive(lval)的结果赋值给rprim</li>
<li>如果Type(lprim)和Type(rprim)中有一个是String，则<br> a. 把ToString(lprim)的结果赋给lstr<br> b. 把ToString(rprim)的结果赋给rstr<br> c. 返回lstr和rstr拼接的字符串</li>
<li>把ToNumber(lprim)的结果赋给lnum</li>
<li>把ToNumber(rprim)的结果赋给rnum</li>
<li>返回lnum和rnum相加的数值</li>
</ol>
<a id="more"></a>

<h1 id="一元-运算符"><a href="#一元-运算符" class="headerlink" title="一元 + 运算符"></a>一元 + 运算符</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>一元运算符“+”是用来把目标转化成数字类型的</p>
<h2 id="运算过程定义-1"><a href="#运算过程定义-1" class="headerlink" title="运算过程定义"></a>运算过程定义</h2><blockquote>
<p>UnaryExpression : + UnaryExpression</p>
</blockquote>
<ol>
<li>把UnaryExpression的result赋值给expr</li>
<li>返回ToNumber(GetValue(expr))</li>
</ol>
<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p><code>ToNumber(GetValue(expr))</code></p>
<p>概括来说就是转换时 <code>hint</code> 为 <code>number</code>，对于原始值类型（<code>Undefined</code>, <code>Null</code>, <code>Boolean</code>, <code>Number</code>, <code>Symbol</code>, <code>String</code>），直接使用内部 <code>ToNumber</code> 转换成数字</p>
<h3 id="ToNumber-转换表格"><a href="#ToNumber-转换表格" class="headerlink" title="ToNumber 转换表格"></a>ToNumber 转换表格</h3><table>
<thead>
<tr>
<th>输入类型</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>Undefined</td>
<td><code>NaN</code></td>
</tr>
<tr>
<td>Null</td>
<td><code>+0</code></td>
</tr>
<tr>
<td>Boolean</td>
<td><code>+0</code> 或者 <code>1</code></td>
</tr>
<tr>
<td>Number</td>
<td>不转换</td>
</tr>
<tr>
<td>String</td>
<td>参见下文的文法与注释</td>
</tr>
<tr>
<td>symbol</td>
<td>TypeError</td>
</tr>
<tr>
<td>Object</td>
<td><code>ToNumber(ToPrimitive(input,Number))</code></td>
</tr>
</tbody></table>
<h1 id="加号运算题目"><a href="#加号运算题目" class="headerlink" title="加号运算题目"></a>加号运算题目</h1><ol>
<li><code>[ ] + [ ]</code></li>
</ol>
<blockquote>
<p>进行 <code>ToPrimitive</code>，两个都是 <code>Array</code> 对象，不是 <code>Date</code> 对象，所以 <code>Number</code> 为转换标准，所以先调用<code>valueOf()</code>，结果还是[ ]，不是原始值，所以继续调用 <code>toString()</code>，结果是“”原始值，将“”回。<br>第二个[ ]过程是相同的，返回“”。<br>加号两边结果都是 <code>String</code> 类型，所以进行字符串拼接，结果是“”。</p>
</blockquote>
<ol start="2">
<li><code>[ ] + { }</code></li>
</ol>
<blockquote>
<p>进行 <code>ToPrimitive</code>，依然是以 <code>Number</code> 为转换标准。<br>[ ]的结果是 “”。<br>{ }先调用 <code>valueOf()</code>，结果是{ }，不是原始值，所以继续调用 <code>toString()</code>，结果是“<code>[object Object]</code>”,是原始值，将“<code>[object Object]</code>”返回。<br>加号两边结果都是 <code>String</code> 类型，所以进行字符串拼接，结果是 “<code>[object Object]</code>“。</p>
</blockquote>
<ol start="3">
<li><code>{ } + [ ]</code></li>
</ol>
<blockquote>
<p>这道题按照上一题的步骤，讲道理的话，结果应该还是“<code>[object Object]</code>”，但结果却如人意料——显示的答案是0.<br>这是什么原因呢？原来{ } + [ ]被解析成了{ };+[ ]，前面是一个空代码块被略过，剩下+[ ]就成了一元运算。[ ]的原值是””， 将””转化成 <code>Number</code> 结果是0。</p>
</blockquote>
<ol start="4">
<li><code>{ } + { }</code></li>
</ol>
<blockquote>
<p>这道题的结果在不同的环境下结果不一样。<br>在金丝雀版本的 chrome 浏览器和 node 中，结果符合预期。结果是”<code>[object Object][object Object]</code>“。<br>在普通版本的 <code>chrome</code> 浏览器中结果是 <code>NaN</code><br>这是为什么呢？原因是在 node 中会将以“{”开始，“}”结束的语句外面包裹一层( )，就变成了 <code>({ } + { })</code>，结果就符合预期。而普通版本的 chrome 依然会解析成 <code>{};+{}</code>，结果就变成了 <code>NaN</code>。</p>
</blockquote>
<ol start="5">
<li><code>++[[ ]][+[ ]]+[+[ ]]</code></li>
</ol>
<blockquote>
<p>拆解过程</p>
<ol>
<li>先拆分成A：<code>++[[ ]][+[ ]]</code> 和 B：<code>[+[ ]]</code></li>
<li>B式比较简单：<code>[0]</code></li>
<li>A式转换成 <code>++[[ ]][0]</code> 也就是 <code>++[ ]</code></li>
<li>A式结果为 1</li>
<li>1 + [0]</li>
<li>结果是 “10”</li>
</ol>
</blockquote>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://sinaad.github.io/xfe/2016/04/15/ToPrimitive/" target="_blank" rel="noopener">js隐式装箱-ToPrimitive</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
        <tag>隐式转换</tag>
      </tags>
  </entry>
  <entry>
    <title>最大子序和 - LeetCode</title>
    <url>/2020/03/08/leetcode-maximum-subarray/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>最大子序和</p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<a id="more"></a>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<p>进阶:</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a><strong>思考</strong></h1><ol>
<li>动态规划法：</li>
<li>分治法：<ul>
<li>定义基本问题。</li>
<li>将问题分解为子问题并递归地解决它们。</li>
<li>合并子问题的解以获得原始问题的解。</li>
</ul>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ol>
<li>解法一：<br>动态规划法：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(nums)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums[i] += nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        maxSum = <span class="built_in">Math</span>.max(maxSum, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：<code>O(N)</code> 。只遍历了一次数组。</li>
<li>空间复杂度：<code>O(1)</code>，使用了常数的空间。</li>
</ul>
<p>执行结果：</p>
<ul>
<li>执行用时: 64 ms, 在所有 JavaScript 提交中击败了 90.83% 的用户</li>
<li>内存消耗: 35.2 MB, 在所有 JavaScript 提交中击败了 68.95% 的用户</li>
</ul>
<ol start="2">
<li>解法二：<br>分治法：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxSubArrayDivideWithBorder(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxSubArrayDivideWithBorder = <span class="function"><span class="keyword">function</span>(<span class="params">nums, start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start === end) <span class="keyword">return</span> nums[start];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算中间值</span></span><br><span class="line">    <span class="keyword">const</span> center = <span class="built_in">Math</span>.floor((start + end) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> maxLeft = maxSubArrayDivideWithBorder(nums, start, center);</span><br><span class="line">    <span class="keyword">const</span> maxRight = maxSubArrayDivideWithBorder(nums, center + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算横跨两个子序列的最大值</span></span><br><span class="line">    <span class="comment">// 计算包含左侧子序列最后一个元素的子序列最大值</span></span><br><span class="line">    <span class="keyword">let</span> maxLeftCross = -<span class="literal">Infinity</span>;</span><br><span class="line">    <span class="keyword">let</span> sumLeftCross = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = center; i &gt;= start; i--) &#123;</span><br><span class="line">        sumLeftCross += nums[i];</span><br><span class="line">        maxLeftCross = <span class="built_in">Math</span>.max(sumLeftCross, maxLeftCross);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> maxRightCross = -<span class="literal">Infinity</span>;</span><br><span class="line">    <span class="keyword">let</span> sumRightCross = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = center + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">        sumRightCross += nums[i];</span><br><span class="line">        maxRightCross = <span class="built_in">Math</span>.max(sumRightCross, maxRightCross);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> maxCross = maxLeftCross + maxRightCross;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(maxCross, maxLeft, maxRight);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：<code>O(NlogN)</code> 。</li>
<li>空间复杂度：<code>O(logN)</code>，递归时栈使用的空间。</li>
</ul>
<p>执行结果：</p>
<ul>
<li>执行用时: 72 ms, 在所有 JavaScript 提交中击败了 62.19% 的用户</li>
<li>内存消耗: 35.3 MB, 在所有 JavaScript 提交中击败了 59.41% 的用户</li>
</ul>
<h1 id="难度"><a href="#难度" class="headerlink" title="难度"></a>难度</h1><p>简单</p>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank" rel="noopener">最大子序和 - LeetCode</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>贪心算法</tag>
        <tag>分治法</tag>
        <tag>Kadane 算法</tag>
      </tags>
  </entry>
  <entry>
    <title>零钱兑换 - LeetCode</title>
    <url>/2020/03/08/leetcode-coin-change/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>零钱兑换</p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<a id="more"></a>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>

<p>说明:<br>你可以认为每种硬币的数量是无限的。</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a><strong>思考</strong></h1><ol>
<li>利用动态规划法</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ol>
<li>解法一：<br>动态规划-自上而下<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">coins</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">amount</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> coinChange = <span class="function"><span class="keyword">function</span>(<span class="params">coins, amount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!coins) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (amount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dpMap = [];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dp</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dpMap[n] &gt;= <span class="number">-1</span>) <span class="keyword">return</span> dpMap[n];</span><br><span class="line">        <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="literal">Infinity</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> sub = dp(n - coins[i]);</span><br><span class="line">            <span class="keyword">if</span> (sub == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            res = <span class="built_in">Math</span>.min(res, sub + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dpMap[n] = res !== <span class="literal">Infinity</span> ? res : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dpMap[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(amount);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：<code>O(Sn)</code>，其中 <code>S</code> 是金额，<code>n</code> 是面额数。我们一共需要计算 <code>S</code> 个状态的答案，且每个状态 <code>F(S)</code> 由于上面的记忆化的措施只计算了一次，而计算一个状态的答案需要枚举 <code>n</code> 个面额值，所以一共需要 <code>O(Sn)</code> 的时间复杂度。</li>
<li>空间复杂度：<code>O(S)</code>，我们需要额外开一个长为 <code>S</code> 的数组来存储计算出来的答案 <code>F(S)</code>。</li>
</ul>
<p>执行结果：</p>
<ul>
<li>执行用时: 232 ms, 在所有 JavaScript 提交中击败了 17.55% 的用户</li>
<li>内存消耗: 38.8 MB, 在所有 JavaScript 提交中击败了 57.46% 的用户</li>
</ul>
<ol start="2">
<li>解法二：<br>动态规划 - 自下而上<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">coins</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">amount</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> coinChange = <span class="function"><span class="keyword">function</span>(<span class="params">coins, amount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(amount + <span class="number">1</span>).fill(<span class="literal">Infinity</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> coin <span class="keyword">of</span> coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - coin &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">Math</span>.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] === <span class="literal">Infinity</span> ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：<code>O(Sn)</code>，其中 <code>S</code> 是金额，<code>n</code> 是面额数。我们一共需要计算 <code>O(S)</code> 个状态，<code>S</code> 为题目所给的总金额。对于每个状态，每次需要枚举 <code>n</code> 个面额来转移状态，所以一共需要 <code>O(Sn)</code> 的时间复杂度。</li>
<li>空间复杂度：<code>O(S)</code>。DP 数组需要开长度为总金额 <code>S</code> 的空间。</li>
</ul>
<p>执行结果：</p>
<ul>
<li>执行用时: 108 ms, 在所有 JavaScript 提交中击败了 79.94% 的用户</li>
<li>内存消耗: 37.2 MB, 在所有 JavaScript 提交中击败了 82.32% 的用户</li>
</ul>
<h1 id="难度"><a href="#难度" class="headerlink" title="难度"></a>难度</h1><p>中等</p>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/coin-change" target="_blank" rel="noopener">零钱兑换 - LeetCode</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>K 个一组翻转链表 - LeetCode</title>
    <url>/2020/03/05/leetcode-reverse-nodes-in-k-group/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>K 个一组翻转链表</p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<a id="more"></a>

<p>示例 :</p>
<p>给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<p>说明 :</p>
<p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a><strong>思考</strong></h1><ol>
<li>解法一:<ol>
<li>利用两个指针来指出每次需要翻转的链表</li>
<li>循环迭代</li>
</ol>
</li>
<li>链表题目经验:<ol>
<li>新建一个哑结点来定位原链表</li>
<li>多指针来存储和定位</li>
</ol>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseKGroup = <span class="function"><span class="keyword">function</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dummy = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> pre = dummy;</span><br><span class="line">    <span class="keyword">let</span> end = dummy;</span><br><span class="line">    <span class="keyword">while</span> (end.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; end != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">            end = end.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end === <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">let</span> start = pre.next;</span><br><span class="line">        <span class="keyword">let</span> next = end.next;</span><br><span class="line">        end.next = <span class="literal">null</span>;</span><br><span class="line">        pre.next = reverse(start);</span><br><span class="line">        start.next = next;</span><br><span class="line">        pre = start;</span><br><span class="line">        end = pre</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reverse = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> next = curr.next;</span><br><span class="line">        curr.next = pre;</span><br><span class="line">        pre = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果<br>执行用时: 84 ms, 在所有 JavaScript 提交中击败了 83.75% 的用户<br>内存消耗: 37.4 MB, 在所有 JavaScript 提交中击败了 93.65% 的用户</li>
</ul>
<h1 id="难度"><a href="#难度" class="headerlink" title="难度"></a>难度</h1><p>困难</p>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group" target="_blank" rel="noopener">K 个一组翻转链表 - LeetCode</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串转换整数 (atoi) - LeetCode</title>
    <url>/2020/03/05/leetcode-string-to-integer-atoi/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>字符串转换整数 (atoi)</p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。<br>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<a id="more"></a>

<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a><strong>思考</strong></h1><ol>
<li>解法一:<br> 纯根据规则来做各种判断</li>
<li>解法二:<br> 利用 js 的 <code>parseInt</code> 函数来转换</li>
<li>解法三:<br> 利用正则来转换</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>解法一:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">str</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> myAtoi = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> len = str.length;</span><br><span class="line">    <span class="keyword">const</span> MAX_VALUE = <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> MIN_VALUE = <span class="built_in">Math</span>.pow(<span class="number">-2</span>, <span class="number">31</span>);</span><br><span class="line">    <span class="comment">// 1. 去空格</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[index] != <span class="string">' '</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index === len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 判断首位是符号的情况</span></span><br><span class="line">    <span class="keyword">let</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (str[index] === <span class="string">'+'</span>) &#123;</span><br><span class="line">        sign = <span class="number">1</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[index] === <span class="string">'-'</span>) &#123;</span><br><span class="line">        sign = <span class="number">-1</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 对数字的判断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[index] &gt; <span class="string">'9'</span> || str[index] &lt; <span class="string">'0'</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = res * <span class="number">10</span> + sign * (str[index] - <span class="string">'0'</span>);</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span> (res &gt; MAX_VALUE) &#123;</span><br><span class="line">            res = MAX_VALUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; MIN_VALUE) &#123;</span><br><span class="line">            res = MIN_VALUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果<br>执行用时: 88 ms, 在所有 JavaScript 提交中击败了 65.27% 的用户<br>内存消耗: 36.5 MB, 在所有 JavaScript 提交中击败了 33.25% 的用户</li>
</ul>
<p>解法二:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">str</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> myAtoi = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    str = str.trim();</span><br><span class="line">    <span class="keyword">const</span> MAX_VALUE = <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> MIN_VALUE = <span class="built_in">Math</span>.pow(<span class="number">-2</span>, <span class="number">31</span>);</span><br><span class="line">    <span class="keyword">const</span> num = <span class="built_in">parseInt</span>(str, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (num &gt; MAX_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; MIN_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isNaN</span>(num) ? <span class="number">0</span> : num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果<br>执行用时: 92 ms, 在所有 JavaScript 提交中击败了 50.40% 的用户<br>内存消耗: 35.8 MB, 在所有 JavaScript 提交中击败了 76.69% 的用户</li>
</ul>
<p>解法三:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">str</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> myAtoi = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    str = str.trim()</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/^[\+\-]?\d+/</span></span><br><span class="line">    <span class="keyword">const</span> res = str.match(reg)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max.call(<span class="literal">null</span>, <span class="built_in">Math</span>.min.call(<span class="literal">null</span>, res, <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>), <span class="built_in">Math</span>.pow(<span class="number">-2</span>, <span class="number">31</span>))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果<br>执行用时: 92 ms, 在所有 JavaScript 提交中击败了 50.40% 的用户<br>内存消耗: 36 MB, 在所有 JavaScript 提交中击败了 67.61% 的用户</li>
</ul>
<h1 id="难度"><a href="#难度" class="headerlink" title="难度"></a>难度</h1><p>中等</p>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi" target="_blank" rel="noopener">字符串转换整数 (atoi) - LeetCode</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>腐烂的橘子 - LeetCode</title>
    <url>/2020/03/03/leetcode-rotting-oranges/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>腐烂的橘子</p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>在给定的网格中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 0 代表空单元格；</li>
<li>值 1 代表新鲜橘子；</li>
<li>值 2 代表腐烂的橘子。</li>
</ul>
<p>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p>
<p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。</p>
<a id="more"></a>

<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a><strong>思考</strong></h1><ol>
<li>解法一:<ol>
<li>第一遍计算出所有的橘子数量并且找出腐烂的橘子放入队列, 作为第 0 层的结点</li>
<li>然后广度优先搜索, 每次搜索外一层, 有相邻新鲜橘子记录起来并推入腐烂橘子队列</li>
<li>最后比较所有的橘子与腐烂的橘子的数量, 返回结果</li>
</ol>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">grid</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> orangesRotting = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!grid) <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> r = grid.length</span><br><span class="line">    <span class="keyword">let</span> c = grid[<span class="number">0</span>].length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> orangesCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> badCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> bad = [];</span><br><span class="line">    <span class="keyword">let</span> day = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> coor = [[<span class="number">-1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">-1</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                orangesCount += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] === <span class="number">2</span>)&#123;</span><br><span class="line">                    bad.push([i, j])</span><br><span class="line">                    badCount += <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (bad.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> hasBad = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">let</span> badLen = bad.length</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; badLen; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> badRC = bad.splice(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">let</span> dr = badRC[<span class="number">0</span>][<span class="number">0</span>] + coor[j][<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">let</span> dc = badRC[<span class="number">0</span>][<span class="number">1</span>] + coor[j][<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span>(dr &gt;=<span class="number">0</span> &amp;&amp; dc &gt;=<span class="number">0</span> &amp;&amp; grid[dr] &amp;&amp; grid[dr][dc] + <span class="number">1</span> === <span class="number">2</span>)&#123;</span><br><span class="line">                    grid[dr][dc] = <span class="number">2</span></span><br><span class="line">                    bad.push([dr, dc])</span><br><span class="line">                    badCount += <span class="number">1</span></span><br><span class="line">                    hasBad = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hasBad &amp;&amp; day ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> orangesCount &gt; badCount ? <span class="number">-1</span> : day</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="难度"><a href="#难度" class="headerlink" title="难度"></a>难度</h1><p>简单</p>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/rotting-oranges" target="_blank" rel="noopener">腐烂的橘子 - LeetCode</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>广度优先搜索(BFS)</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 数据类型整理</title>
    <url>/2020/03/01/javascript-data-type/</url>
    <content><![CDATA[<h1 id="JavaScript-数据类型"><a href="#JavaScript-数据类型" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h1><ul>
<li>7 种原始类型:<br><code>Number</code> / <code>String</code> / <code>Boolean</code> / <code>Undefined</code> / <code>Null</code> / <code>BigInt</code> / <code>Symbol</code></li>
<li>Object</li>
</ul>
<h1 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h1><p>除 Object 以外的所有类型都是不可变的</p>
<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>JavaScript的字符串类型用于表示文本数据。它是一组16位的无符号整数值的“元素”</p>
<h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(253 -1) 到 253 -1）</p>
<p>还有一些带符号的值：<code>+Infinity</code>，<code>-Infinity</code> 和 <code>NaN</code>(非数值，Not-a-Number)</p>
<p>要检查值是否大于或小于 <code>+/-Infinity</code>, 你可以使用常量 <code>Number.MAX_VALUE</code> 和 <code>Number.MIN_VALUE</code></p>
<p>在 ECMAScript 6 中，你也可以通过 <code>Number.isSafeInteger()</code> 方法还有 <code>Number.MAX_SAFE_INTEGER</code> 和 <code>Number.MIN_SAFE_INTEGER</code> 来检查值是否在双精度浮点数的取值范围内</p>
<a id="more"></a>


<h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>布尔表示一个逻辑实体，可以有两个值：<code>true</code> 和 <code>false</code></p>
<h2 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a>Null 类型</h2><p>Null 类型只有一个值： null</p>
<h2 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h2><p>一个没有被赋值的变量会有个默认值 <code>undefined</code></p>
<h2 id="BigInt-类型"><a href="#BigInt-类型" class="headerlink" title="BigInt 类型"></a>BigInt 类型</h2><p>BigInt类型是 JavaScript 中的一个基础的数值类型，可以用任意精度表示整数</p>
<h2 id="符号类型"><a href="#符号类型" class="headerlink" title="符号类型"></a>符号类型</h2><p>符号类型是唯一的并且是不可修改的, 并且也可以用来作为Object的key的值</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>属性使用键来标识，它的键值可以是一个字符串或者符号值（Symbol）</p>
<p>ECMAScript定义的对象中有两种属性：数据属性和访问器属性。</p>
<h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性是键值对，并且每个数据属性拥有下列特性:</p>
<h4 id="数据属性的特性-Attributes-of-a-data-property"><a href="#数据属性的特性-Attributes-of-a-data-property" class="headerlink" title="数据属性的特性(Attributes of a data property)"></a>数据属性的特性(Attributes of a data property)</h4><table>
<thead>
<tr>
<th>特性</th>
<th>数据类型</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>[[Value]]</td>
<td>任何Javascript类型</td>
<td>包含这个属性的数据值</td>
<td>undefined</td>
</tr>
<tr>
<td>[[Writable]]</td>
<td>Boolean</td>
<td>如果该值为 false，则该属性的 [[Value]] 特性 不能被改变</td>
<td>true</td>
</tr>
<tr>
<td>[[Enumerable]]</td>
<td>Boolean</td>
<td>如果该值为 true，则该属性可以用 for…in 循环来枚举</td>
<td>true</td>
</tr>
<tr>
<td>[[Configurable]]</td>
<td>Boolean</td>
<td>如果该值为 false，则该属性不能被删除，并且 除了 [[Value]] 和 [[Writable]] 以外的特性都不能被改变。</td>
<td>true</td>
</tr>
</tbody></table>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>访问器属性有一个或两个访问器函数 (get 和 set) 来存取数值，并且有以下特性:</p>
<h4 id="一个访问器属性的特性"><a href="#一个访问器属性的特性" class="headerlink" title="一个访问器属性的特性"></a>一个访问器属性的特性</h4><table>
<thead>
<tr>
<th>特性</th>
<th>类型</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>[[Get]]</td>
<td>函数对象或者 undefined</td>
<td>该函数使用一个空的参数列表，能够在有权访问的情况下读取属性值。另见 get。</td>
<td>undefined</td>
</tr>
<tr>
<td>[[Set]]</td>
<td>函数对象或者 undefined</td>
<td>该函数有一个参数，用来写入属性值，另见 set。</td>
<td>undefined</td>
</tr>
<tr>
<td>[[Enumerable]]</td>
<td>Boolean</td>
<td>如果该值为 true，则该属性可以用 for…in 循环来枚举。</td>
<td>true</td>
</tr>
<tr>
<td>[[Configurable]]</td>
<td>Boolean</td>
<td>如果该值为 false，则该属性不能被删除，并且不能被转变成一个数据属性。</td>
<td>true</td>
</tr>
</tbody></table>
<h2 id="“标准的”-对象-和函数"><a href="#“标准的”-对象-和函数" class="headerlink" title="“标准的” 对象, 和函数"></a>“标准的” 对象, 和函数</h2><p>一个 Javascript 对象就是键和值之间的映射</p>
<p><strong>函数</strong> 是一个附带可被调用功能的常规对象。</p>
<h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><p>当你想要显示日期时，毋庸置疑，使用内建的 <code>Date</code> 对象。</p>
<h2 id="有序集-数组和类型数组"><a href="#有序集-数组和类型数组" class="headerlink" title="有序集: 数组和类型数组"></a>有序集: 数组和类型数组</h2><p><strong>数组</strong> 是一种使用整数作为键(integer-key-ed)属性和长度(length)属性之间关联的常规对象</p>
<p>数组对象还继承了 Array.prototype 的一些操作数组的便捷方法</p>
<h3 id="类型数组-Typed-Arrays"><a href="#类型数组-Typed-Arrays" class="headerlink" title="类型数组(Typed Arrays)"></a>类型数组(Typed Arrays)</h3><p><strong>类型数组(Typed Arrays)</strong> 是ECMAScript Edition 6中新定义的 JavaScript 内建对象，提供了一个基本的二进制数据缓冲区的类数组视图</p>
<h2 id="键控集-Maps-Sets-WeakMaps-WeakSets"><a href="#键控集-Maps-Sets-WeakMaps-WeakSets" class="headerlink" title="键控集: Maps, Sets, WeakMaps, WeakSets"></a>键控集: Maps, Sets, WeakMaps, WeakSets</h2><ul>
<li>这些数据结构把对象的引用当作键</li>
<li>当 <code>Map</code> 和 <code>WeakMap</code> 把一个值和对象关联起来的时候， <code>Set</code> 和 <code>WeakSet</code> 表示一组对象</li>
<li><code>Map</code> 和 <code>WeakMaps</code> 之间的差别在于，在前者中，对象键是可枚举的</li>
</ul>
<h2 id="结构化数据-JSON"><a href="#结构化数据-JSON" class="headerlink" title="结构化数据: JSON"></a>结构化数据: JSON</h2><p><code>JSON (JavaScript Object Notation)</code> 是一种轻量级的数据交换格式，来源于 JavaScript 同时也被多种语言所使用。 JSON 用于构建通用的数据结构</p>
<h1 id="对象转换到基本类型值算法"><a href="#对象转换到基本类型值算法" class="headerlink" title="对象转换到基本类型值算法"></a>对象转换到基本类型值算法</h1><p>JavaScript 对象什么场景下会转换到基本类型值:</p>
<ul>
<li>数学运算：obj1 + obj2、obj1 - obj2 等</li>
<li>期望值是基本类型值的运算：alert(obj)</li>
</ul>
<h2 id="ToPrimitive-算法"><a href="#ToPrimitive-算法" class="headerlink" title="ToPrimitive 算法"></a>ToPrimitive 算法</h2><p>JavaScript 对象转换到基本类型值时，会使用 <code>ToPrimitive ( input [ , PreferredType ] )</code> 算法，这是一个内部算法，是编程语言在内部执行时遵循的一套规则。</p>
<h3 id="hint"><a href="#hint" class="headerlink" title="hint"></a>hint</h3><p>ToPrimitive 算法在执行时，会被传递一个参数 hint，表示这是一个什么类型的运算（也可以叫运算的期望值），根据这个 hint 参数，ToPrimitive 算法来决定内部的执行逻辑。</p>
<p><code>PreferredType</code> 表示对象将要转换的类型:</p>
<ul>
<li><code>PreferredType</code> 未传递，则令 hint 为 <code>default</code></li>
<li><code>PreferredType</code> 为 String，则 hint 为 <code>string</code></li>
<li><code>PreferredType</code> 为 Number，则 hint 为 <code>number</code></li>
</ul>
<h3 id="转换算法"><a href="#转换算法" class="headerlink" title="转换算法"></a>转换算法</h3><p>当对象发生到基本类型值的转换时，会按照下面的逻辑调用对象上的方法：</p>
<ol>
<li>如果存在，调用 <code>obj[Symbol.toPrimitive](hint)</code></li>
<li>否则，如果 hint 取值是 “<code>string</code>“:<ol>
<li>首先调用 <code>obj.toString()</code>, 如果是原始值则返回</li>
<li>否则再用 <code>obj.valueOf()</code>, 如果是原始值则返回</li>
<li>否则会报 <code>TypeError</code> 错误</li>
</ol>
</li>
<li>否则（也就是 hint 取值是 “<code>number</code>“ 或 “<code>default</code>“ 的情况）:<ol>
<li>首先调用 <code>obj.valueOf()</code>, 如果是原始值则返回</li>
<li>否则再用 <code>obj.toString()</code>, 如果是原始值则返回</li>
<li>否则会报 <code>TypeError</code> 错误</li>
</ol>
</li>
</ol>
<h4 id="例外-Date"><a href="#例外-Date" class="headerlink" title="例外 Date"></a>例外 <code>Date</code></h4><p><code>Date</code> 对象没有 <code>hint</code>, 认为 <code>hint</code> 是 <code>string</code></p>
<h3 id="确定-hint"><a href="#确定-hint" class="headerlink" title="确定 hint"></a>确定 hint</h3><p>用代码打印 <code>hint</code> 值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个没有提供 Symbol.toPrimitive 属性的对象，参与运算时的输出结果</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(+obj1);         <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj1&#125;</span>`</span>);     <span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1 + <span class="string">""</span>);     <span class="comment">// "[object Object]"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下面声明一个对象，手动赋予了 Symbol.toPrimitive 属性，再来查看输出结果</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hint == <span class="string">"number"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hint == <span class="string">"string"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(+obj2);         <span class="comment">// 10       -- hint 参数值是 "number"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj2&#125;</span>`</span>);     <span class="comment">// "hello"   -- hint 参数值是 "string"</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2 + <span class="string">""</span>);     <span class="comment">// "true"    -- hint 参数值是 "default"</span></span><br></pre></td></tr></table></figure>

<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>Symbol.toPrimitive</code> 和 <code>toString</code> 方法的返回值必须是 <strong>基本类型值</strong></li>
<li><code>valueOf</code> 方法除了可以返回 <strong>基本类型值</strong>，也可以返回 <strong>其他类型值</strong></li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>当我们创建一个普通对象时（<code>{}</code> 或 <code>new Object()</code> 的方式等），对象上是不具备 <code>[Symbol.toPrimitive]</code> （方法）属性的。所以，对于普通对象的到基本类型值的运算，一般按照具体场景：</p>
<ol>
<li><code>hint</code> 值为 “<code>string</code>“ 时，先调用 <code>toString</code>，<code>toString</code> 如果返回一个基本类型值了，则返回、终止运算；否则接着调用 <code>valueOf</code> 方法</li>
<li>否则，先调用 <code>valueOf</code>，<code>valueOf</code> 如果返回一个基本类型值了，则返回、终止运算；否则接着调用 <code>toString</code> 方法</li>
</ol>
<h2 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h2><p>JavaScript调用valueOf方法将对象转换为原始值, 默认情况下, valueOf方法由Object后面的每个对象继承。 每个内置的核心对象都会覆盖此方法以返回适当的值。如果对象没有原始值, 则valueOf将返回对象本身。</p>
<h3 id="不同类型对象的valueOf-方法的返回值"><a href="#不同类型对象的valueOf-方法的返回值" class="headerlink" title="不同类型对象的valueOf()方法的返回值"></a>不同类型对象的valueOf()方法的返回值</h3><table>
<thead>
<tr>
<th>对象</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>Array</td>
<td>返回数组对象本身</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔值</td>
</tr>
<tr>
<td>Date</td>
<td>存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC</td>
</tr>
<tr>
<td>Function</td>
<td>函数本身</td>
</tr>
<tr>
<td>Number</td>
<td>数字值</td>
</tr>
<tr>
<td>Object</td>
<td>对象本身。这是默认情况</td>
</tr>
<tr>
<td>String</td>
<td>字符串值</td>
</tr>
<tr>
<td></td>
<td>Math 和 Error 对象没有 valueOf 方法</td>
</tr>
</tbody></table>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><p>每个对象都有一个 <code>toString()</code> 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，<code>toString()</code> 方法被每个 <code>Object</code> 对象继承。如果此方法在自定义对象中未被覆盖，<code>toString()</code> 返回 “<code>[object type]</code>“，其中 <code>type</code>是对象的类型.</p>
<h3 id="toSting-运算"><a href="#toSting-运算" class="headerlink" title="toSting 运算"></a>toSting 运算</h3><table>
<thead>
<tr>
<th>输入</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>null</td>
<td>‘null’</td>
</tr>
<tr>
<td>undefined</td>
<td>‘undefined’</td>
</tr>
<tr>
<td>number</td>
<td>参照§7.1.12.1</td>
</tr>
<tr>
<td>boolean</td>
<td>‘true’ / ‘false’</td>
</tr>
<tr>
<td>string</td>
<td>不转换</td>
</tr>
<tr>
<td>symbol</td>
<td>TypeError</td>
</tr>
<tr>
<td>object</td>
<td>ToString(ToPrimitive(input,String))</td>
</tr>
</tbody></table>
<h3 id="覆盖了-toString-属性的对象类型"><a href="#覆盖了-toString-属性的对象类型" class="headerlink" title="覆盖了 toString 属性的对象类型"></a>覆盖了 toString 属性的对象类型</h3><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><ul>
<li>valueOf(): 返回对象本身</li>
<li>toString(): 相当于数组值调用 join(‘,’) 返回的字符串<br>  例如: [1,2,3].toString() =&gt; “1,2,3”</li>
</ul>
<h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><ul>
<li>valueOf(): 返回对象本身</li>
<li>toString(): 返回函数中包含的代码转为字符串值</li>
</ul>
<h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><ul>
<li>valueOf(): 返回给定的时间转为UNIX时间(自1 January 1970 00:00:00 UTC起算)，但是以微秒计算的数字值</li>
<li>toString(): 返回本地化的时间字符串</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="http://zhoushengfe.com/es6/es6-ch.html" target="_blank" rel="noopener">ECMAScript® 2016 语言规范</a></li>
<li><a href="http://yanhaijing.com/es5" target="_blank" rel="noopener">ECMAScript5.1中文版</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
        <tag>隐式转换</tag>
      </tags>
  </entry>
</search>
